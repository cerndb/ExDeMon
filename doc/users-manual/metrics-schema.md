# Metrics schemas

Schemas serve to interpret the output (JSON) of a [metrics source](metric-sources.md) and convert it to [metrics](metrics.md) that can be understood by the application. 

More than one schema can be associated to a source and one schema can be associated to one or more sources.

Metrics generated by each schema will have an attribute with key "$schema" and value the ID of the schema.

You can apply a [metrics filter](metrics-filter.md). This way you make sure that the schema is applied to the metrics that the schema should be concerned of (a certain incoming type).
NOTE: filter is applied after parsing, so it can only be applied to the timestamp and attributes that are parsed in the schema. 

The configuration parameters are the following:

```
metrics.schema.<schema-id>.sources = <space-separated-source-ids>
metrics.schema.<schema-id>.timestamp.key = <attribute that represent the time|not set>
metrics.schema.<schema-id>.timestamp.regex = <one-group-regular-expression> (default: not set)
metrics.schema.<schema-id>.timestamp.format = <timestamp_format> (default: auto)
metrics.schema.<schema-id>.timestamp.shift = <period like -1h, -3m or 45s[, truncate d, h, m]> (default: not set)
metrics.schema.<schema-id>.attributes.<alias-1>.key = <key-to-attribute-1>|<one-group-regular-expression>
metrics.schema.<schema-id>.attributes.<alias-1>.value = <value>
metrics.schema.<schema-id>.attributes.<alias-1>.regex = <one-group-regular-expression> (default: not set)
metrics.schema.<schema-id>.attributes.<alias-n> = <key-to-attribute-n>
metrics.schema.<schema-id>.value.<value-id-1>.key = <key-to-value>
metrics.schema.<schema-id>.value.<value-id-1>.type = <string|numeric|boolean|auto> (default: auto)
metrics.schema.<schema-id>.value.<value-id-1>.regex = <one-group-regular-expression> (default: not set)
metrics.schema.<schema-id>.value.<value-id-n>....
metrics.schema.<schema-id>.filter.<configs at Metrics filter> = <values>
```

"timestamp.key" indicates the key in the JSON document that contains the timestamp for the metric. If not configured, current time is set to the metric. If it is configured and the JSON document does not contain the timestamp value, no metric will be generated.

With "timestamp.regex", you can extract the timestamp from the text contained in the value of the specified key ("timestamp.key").

"timestamp.format" indicates the format of the timestamp stored in the attribute configured by "timestamp.attribute". If the format is a number that represents epoch in milliseconds, it must be set to "epoch-ms", if seconds "epoch-s". If the JSON document contains a timestamp with wrong format, metric with exception value will be generated, setting the timestamp to current time. By default, it automatically detects epoch-ms, epoch-s, "yyyy-MM-dd HH:mm:ssZ" and "yyyy-MM-dd'T'HH:mm:ssZ" formats.

You can shift and truncate the parsed timestamp with "timestamp.shift". An example to remove 1h and truncate by day would be: -1h,d

"attributes.&lt;alias>.key" configures the keys that will be extracted from the JSON document.
If the JSON document does not contain the attribute, the metric will not contain such attribute.
Key can be a regular expression, if so it must contain a group and alias must contain a "+". "+" in the alias will be replaced with the content of the group. Example:

```
metrics.schema.<schema-id>.attributes.data-+.key = data.payload.(.*)

# Incoming JSON
{
    "data":{
        "payload":{
            "first": 1,
            "second": 2
        }
    },
    //rest of the document...
}

# Generates metric with attributes:
#   data-first = 1
#   data-second = 2
```

With "attributes.&lt;alias>.value", you can establish a fix value for an attribute. Instead of writing the key to the JSON document, you would.

```
metrics.schema.<schema-id>.attributes.puppet_environment.value
```

With "attributes.&lt;value-id>.regex" you can extract the value from a text contained in the value of the specified key. It must have one group.

```
metrics.schema.<schema-id>.attributes.server_number.key = request.server
metrics.schema.<schema-id>.attributes.server_number.regex = host-(.*)

# Incoming JSON
{
    "request":{
        "server": "host-124"
    },
    //rest of the document...
}

# Generates metric with attributes:
#   server_number = 124
```

"value.&lt;value-id>.key" configure the keys from which metric values will be extracted from the JSON document. A metric will be created for each &lt;value-id>, all metrics generated from the same JSON document will share the same timestamp and attributes. All generated metrics will contain an extra attribute with name "$value", its value indicates the &lt;value-id>. 

If JSON document does not contain the value, the metric will not be generated. Type of generated metrics will be determined automatically by the corresponding JSON type, or can by specified with "value.&lt;value-id>.type".

With "value.&lt;value-id>.regex" you can extract the value from a text contained in the value of the specified key.

An example of JSON document could be:

```
{
	"headers":{
		"TIMESTAMP": "2017-11-01T10:29:14+02:00",
		"hostname": "host-1234.cern.ch"
	},"body":{
		"CPUUsage": 295.13,
		"IsWriteActive": true,
		"CPUName": "The CPU name is Intel Core i8"
	}
}
```

For this document, the configuration would look like the following.

```
metrics.schema.<schema-id>.timestamp.keys = header.TIMESTAMP

metrics.schema.<schema-id>.attributes.hostname.key = headers.hostname

metrics.schema.<schema-id>.value.CPUUsage.key = body.CPUUsage
metrics.schema.<schema-id>.value.IsWriteActive.key = body.IsWriteActive
metrics.schema.<schema-id>.value.CPUName.key = body.CPUName
metrics.schema.<schema-id>.value.CPUName.regex = The CPU name is (.*)
```

In this case, three metrics will be generated per JSON document (as many as values). Generated metrics will be:
If aliases are used:
* Metric with timestamp "2017-11-01T10:29:14+02:00", value 295.13 and attributes:
  * hostname = "host-1234.cern.ch"
  * $value = "CPUUsage"
* Metric with timestamp "2017-11-01T10:29:14+02:00", value true and attributes:
  * hostname = "host-1234.cern.ch"
  * $value = "IsWriteActive"
* Metric with timestamp "2017-11-01T10:29:14+02:00", value "Intel Core i8" and attributes:
  * hostname = "host-1234.cern.ch"
  * $value = "CPUName"