# Metrics schemas

Schemas serve to interpret the output (JSON) of a [metrics source](metric-sources.md) and convert it to [metrics](metrics.md) that can be understood by the application. 

More than one schema can be associated to a source and one schema can be associated to one or more sources.

Metrics generated by each schema will have an attribute with key "$schema" and value the ID of the schema.

You can apply a [metrics filter](metrics-filter.md). This way you make sure that the schema is applied to the metrics that the schema should be concerned of (a certain incoming type).
NOTE: filter is applied after parsing, so it can only be applied to the attributes that are parsed in the schema. If you want to filter on attributes that are not parsed, you need to parse them. 

The configuration parameters are the following:

```
metrics.schema.<schema-id>.sources = <space-separated-source-ids>
metrics.schema.<schema-id>.timestamp.key = <attribute that represent the time|not set>
metrics.schema.<schema-id>.timestamp.format = <timestamp_format> (default: auto)
metrics.schema.<schema-id>.attributes.<alias-1> = <key-to-attribute-1>
metrics.schema.<schema-id>.attributes.<alias-2> = <key-to-attribute-2>
metrics.schema.<schema-id>.attributes.<alias-n> = <key-to-attribute-n>
metrics.schema.<schema-id>.value.<value-id-1>.key = <key-to-value>
metrics.schema.<schema-id>.value.<value-id-1>.type = <string|numeric|boolean|auto> (default: auto)
metrics.schema.<schema-id>.value.<value-id-1>.regex = <regular-expression> (default: not set)
metrics.schema.<schema-id>.value.<value-id-n>....
metrics.schema.<schema-id>.filter.<configs at Metrics filter> = <values>
```

"timestamp.key" indicates the key in the JSON document that contains the timestamp for the metric. If not configured, current time is set to the metric. If it is configured and the JSON document does not contain the timestamp value, no metric will be generated.

"timestamp.format" indicates the format of the timestamp stored in the attribute configured by "timestamp.attribute". If the format is a number that represents epoch in milliseconds, it must be set to "epoch-ms", if seconds "epoch-s". If the JSON document contains a timestamp with wrong format, metric with exception value will be generated, setting the timestamp to current time. By default, it automatically detects epoch-ms, epoch-s, "yyyy-MM-dd HH:mm:ssZ" and "yyyy-MM-dd'T'HH:mm:ssZ" formats.

"attributes.&lt;alias>" configure the keys that will be extracted from the JSON document.
Assigned alias will be used to refer to the attribute in any metric filter.
If the JSON document does not contain the attribute, the metric will not contain such attribute.
Key can be a regular expressions (e.g. data.*). You can combine alias and regular expressions, if alias contain a "+" and key is a regular expression with a group, "+" in the alias will be replaced with the content of the group. Example:

```
metrics.schema.<schema-id>.attributes.data-+ = data.payload.(.*)

# Incoming JSON with:
#   data.payload.first = 1
#   data.payload.second = 2

# Generates metric with attributes:
#   data-first = 1
#   data-second = 2
```

With "attributes.&lt;alias>", you can also establish a fix value for an attribute. Instead of writing the key to the JSON document, you write the desired fixed value starting with the character #. Example:

```
# All metrics generated by this schema will have an attribute with key "puppet_environment" and value "qa".

metrics.schema.<schema-id>.attributes.puppet_environment = #qa
```

"value.&lt;value-id>.key" configure the keys from which metric values will be extracted from the JSON document. A metric will be created for each &lt;value-id>, all metrics generated from the same JSON document will share the same timestamp and attributes. All generated metrics will contain an extra attribute with name "$value", its value indicates the &lt;value-id>. 

If JSON document does not contain the value, the metric will not be generated. Type of generated metrics will be determined automatically by the corresponding JSON type, or can by specified with "value.&lt;value-id>.type".

With "value.&lt;value-id>.regex" you can extract the value from a text contained in the value of the specified key.

An example of JSON document could be:

```
{
	"headers":{
		"TIMESTAMP": "2017-11-01T10:29:14+02:00",
		"hostname": "host-1234.cern.ch"
	},"body":{
		"CPUUsage": 295.13,
		"IsWriteActive": true,
		"CPUName": "The CPU name is Intel Core i8"
	}
}
```

For this document, the configuration would looks like the following.

```
metrics.schema.<schema-id>.timestamp.keys = header.TIMESTAMP

metrics.schema.<schema-id>.attributes.hostname = headers.hostname

metrics.schema.<schema-id>.value.CPUUsage.key = body.CPUUsage
metrics.schema.<schema-id>.value.IsWriteActive.key = body.IsWriteActive
metrics.schema.<schema-id>.value.CPUName.key = body.CPUName
metrics.schema.<schema-id>.value.CPUName.regex = The CPU name is (.*)
```

In this case, three metrics will be generated per JSON document (as many as values). Generated metrics will be:
If aliases are used:
* Metric with timestamp "2017-11-01T10:29:14+02:00", value 295.13 and attributes:
  * hostname = "host-1234.cern.ch"
  * $value = "CPUUsage"
* Metric with timestamp "2017-11-01T10:29:14+02:00", value true and attributes:
  * hostname = "host-1234.cern.ch"
  * $value = "IsWriteActive"
* Metric with timestamp "2017-11-01T10:29:14+02:00", value "Intel Core i8" and attributes:
  * hostname = "host-1234.cern.ch"
  * $value = "CPUName"